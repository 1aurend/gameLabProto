'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _pieces = require('./pieces.js');

var _pieces2 = _interopRequireDefault(_pieces);

var _colors = require('./colors.js');

var _colors2 = _interopRequireDefault(_colors);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function Piece() {
  this.width = 20;
  this.height = 20;
  this.x = 5;
  this.y = 0;
  this.color = _colors2.default.getRandomColor();
  this.getRandomPiece = function () {
    return _pieces2.default[Math.floor(Math.random() * _pieces2.default.length)].piece;
  };
  this.grid = this.getRandomPiece();
  this.gameOver = false;

  this.draw = function (context) {

    for (var row = 0; row < this.grid.length; row++) {
      for (var col = 0; col < this.grid[row].length; col++) {
        if (this.grid[row][col] !== 0) {
          var x = (col + this.x) * this.width;
          var y = (row + this.y) * this.height;
          context.fillStyle = this.color;
          context.fillRect(x + 1, y + 1, this.width - 2, this.height - 2);
          context.fillStyle = 'rgba(255, 255, 255, 0.4)';
          context.fillRect(x + 1, y + 1, this.width - 2, this.height - 18);
          context.fillRect(x + 1, y + 1, this.width - 19, this.height - 1);
          context.fillStyle = 'rgba(0, 0, 0, 0.4)';
          context.fillRect(x + 1, y + 18, this.width - 2, this.height - 18);
          context.fillRect(x + 18, y + 1, this.width - 19, this.height - 1);
        }
      }
    }
  };

  this.rotateRight = function (board) {
    var array = this.grid;
    var newArray = array[0].map(function (col, i) {
      return array.map(function (row) {
        return row[i];
      }).reverse();
    });

    this.grid = newArray;

    while (this.isCollision(board)) {
      this.x++;

      if (this.x > 5) {
        while (this.isCollision(board)) {
          this.x--;

          if (this.x < 1) {
            this.grid = array;
            break;
          }
        }
        break;
      }
    }
  };

  this.rotateLeft = function () {
    // rotate anti clockwise
  };

  this.generateNewPiece = function (board) {
    this.x = 5;
    this.y = 0;
    this.grid = this.getRandomPiece();
    this.color = _colors2.default.getRandomColor();

    if (this.isCollision(board)) {
      this.gameOver = true;
      board.gameOver = true;
    }
  };

  this.move = function (dir, board) {
    if (this.gameOver) {
      return;
    }

    var currentPositionX = this.x;

    if (dir === 'down') {
      this.drop(board);
    } else if (dir === 'left') {
      this.x--;

      if (this.isCollision(board)) {
        this.x++;
      }
    } else if (dir === 'right') {
      this.x++;

      if (this.isCollision(board)) {
        this.x--;
      }
    }
  };

  this.drop = function (board) {
    if (this.gameOver) {
      return;
    }

    this.y++;

    if (this.isCollision(board)) {
      this.merge(board);
      this.generateNewPiece(board);
    }
  };

  this.isCollision = function (board) {
    for (var row = 0; row < this.grid.length; row++) {
      for (var col = 0; col < this.grid[row].length; col++) {
        if (this.grid[row][col] === 1) {
          // get the actual coordinates to check
          var x = this.x + col;
          var y = this.y + row;
          if (!board.grid[y] || board.grid[y][x] !== 0) {
            return true;
          }
        }
      }
    }

    return false;
  };

  this.merge = function (board) {
    // because we want to wait until it "ticked" one extra step before it's considered landing we have to move it back up one step to merge it in the right place
    this.y--;

    for (var row = 0; row < this.grid.length; row++) {
      for (var col = 0; col < this.grid[row].length; col++) {
        if (this.grid[row][col] === 1) {
          var x = this.x + col;
          var y = this.y + row;
          board.grid[y][x] = this.color;
        }
      }
    }
  };

  this.update = function (board) {
    this.drop(board);
  };
}

exports.default = Piece;
{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\nvar _slicedToArray = function () {\n  function sliceIterator(arr, i) {\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n    var _e = undefined;\n\n    try {\n      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n        _arr.push(_s.value);\n\n        if (i && _arr.length === i) break;\n      }\n    } catch (err) {\n      _d = true;\n      _e = err;\n    } finally {\n      try {\n        if (!_n && _i[\"return\"]) _i[\"return\"]();\n      } finally {\n        if (_d) throw _e;\n      }\n    }\n\n    return _arr;\n  }\n\n  return function (arr, i) {\n    if (Array.isArray(arr)) {\n      return arr;\n    } else if (Symbol.iterator in Object(arr)) {\n      return sliceIterator(arr, i);\n    } else {\n      throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n    }\n  };\n}();\n\nexports.animateMonsters = animateMonsters;\n\nvar _constants = require('../constants');\n\nvar constants = _interopRequireWildcard(_constants);\n\nvar _tracks = require('./tracks');\n\nvar _tracks2 = _interopRequireDefault(_tracks);\n\nvar _movement = require('./movement');\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  } else {\n    var newObj = {};\n\n    if (obj != null) {\n      for (var key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];\n      }\n    }\n\n    newObj.default = obj;\n    return newObj;\n  }\n}\n\nfunction _objectWithoutProperties(obj, keys) {\n  var target = {};\n\n  for (var i in obj) {\n    if (keys.indexOf(i) >= 0) continue;\n    if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;\n    target[i] = obj[i];\n  }\n\n  return target;\n}\n\nfunction getAvailableVectors(_ref) {\n  var newPosition = _ref.newPosition,\n      plane = _ref.plane,\n      trackTo = _ref.trackTo,\n      distanceFromTrack = _ref.distanceFromTrack,\n      movedDistance = _ref.movedDistance,\n      availableOptions = _ref.availableOptions,\n      player = _ref.player,\n      eating = _ref.eating;\n  return availableOptions.map(function (direction) {\n    var _orderPolarity = (0, _movement.orderPolarity)(direction),\n        optionPolarity = _orderPolarity.polarity,\n        optionPlane = _orderPolarity.plane;\n\n    var position = null;\n\n    if (plane === optionPlane) {\n      position = newPosition;\n    } else {\n      position = [];\n      position[optionPlane] = newPosition[optionPlane] + Math.max(0, movedDistance - distanceFromTrack) * optionPolarity;\n      position[1 - optionPlane] = trackTo;\n    }\n\n    var compare = [];\n    compare[optionPlane] = newPosition[optionPlane] + optionPolarity;\n    compare[1 - optionPlane] = position[1 - optionPlane];\n    return {\n      compare: compare,\n      position: position,\n      direction: direction\n    };\n  }).sort(function (_ref2, _ref3) {\n    var posA = _ref2.compare;\n    var posB = _ref3.compare;\n    return Math.pow(-1, eating >> 0) * ((0, _movement.gridDistance)(posA, player.position) - (0, _movement.gridDistance)(posB, player.position));\n  }).map(function (_ref4) {\n    var direction = _ref4.direction,\n        position = _ref4.position;\n    return {\n      direction: direction,\n      position: position\n    };\n  });\n}\n\nfunction getNextMonsterHomePosition(newPosition, monster, player) {\n  if (monster.direction === constants.EAST && monster.position[0] < constants.MONSTER_HOME_EXIT_COL && newPosition[0] >= constants.MONSTER_HOME_EXIT_COL || monster.direction === constants.WEST && monster.position[0] > constants.MONSTER_HOME_EXIT_COL && newPosition[0] <= constants.MONSTER_HOME_EXIT_COL) {\n    return {\n      position: [constants.MONSTER_HOME_EXIT_COL, newPosition[1]],\n      direction: constants.NORTH\n    };\n  }\n\n  if (monster.direction === constants.NORTH && monster.position[1] < constants.MONSTER_HOME_RANGE[constants.NORTH] && newPosition[1] >= constants.MONSTER_HOME_RANGE[constants.NORTH]) {\n    return {\n      position: [newPosition[0], constants.MONSTER_HOME_RANGE[constants.NORTH]],\n      direction: !monster.directionBias && monster.position[0] < player.position[0] ? constants.EAST : constants.WEST\n    };\n  }\n\n  return {\n    position: newPosition\n  };\n}\n\nfunction getIsHome(monster) {\n  return monster.position[0] > constants.MONSTER_HOME_RANGE[constants.WEST] && monster.position[0] < constants.MONSTER_HOME_RANGE[constants.EAST] && monster.position[1] > constants.MONSTER_HOME_RANGE[constants.SOUTH] && monster.position[1] < constants.MONSTER_HOME_RANGE[constants.NORTH];\n}\n\nfunction getAvailableMonsterRoutes(_ref5) {\n  var newPosition = _ref5.newPosition,\n      collision = _ref5.collision,\n      plane = _ref5.plane,\n      trackTo = _ref5.trackTo,\n      monster = _ref5.monster;\n  var availableOptions = [];\n  var distanceFromTrack = 0;\n\n  if (trackTo !== -1 && _tracks2.default[1 - plane][trackTo]) {\n    var passedTrack = _tracks2.default[1 - plane][trackTo].find(function (_ref6) {\n      var _ref7 = _slicedToArray(_ref6, 2),\n          start = _ref7[0],\n          end = _ref7[1];\n\n      return newPosition[1 - plane] >= start && newPosition[1 - plane] <= end;\n    });\n\n    var options = [null, null];\n\n    if (passedTrack[0] < newPosition[1 - plane]) {\n      options[0] = plane === 0 ? constants.SOUTH : constants.WEST;\n    }\n\n    if (passedTrack[1] > newPosition[1 - plane]) {\n      options[1] = plane === 0 ? constants.NORTH : constants.EAST;\n    }\n\n    availableOptions = options.filter(function (item) {\n      return item !== null;\n    });\n    distanceFromTrack = Math.abs(newPosition[plane] - trackTo);\n  }\n\n  if (!collision) {\n    availableOptions.push(monster.direction);\n  }\n\n  return {\n    availableOptions: availableOptions,\n    distanceFromTrack: distanceFromTrack\n  };\n}\n\nfunction getNavigatedMonsterVector(newPosition, collision, movedDistance, monster, player) {\n  // determine where to move a monster if it has a decision to make\n  var _orderPolarity2 = (0, _movement.orderPolarity)(monster.direction),\n      order = _orderPolarity2.order,\n      plane = _orderPolarity2.plane;\n\n  var trackTo = (0, _movement.snapToTrack)(plane, order, newPosition, movedDistance);\n\n  if (trackTo === -1 && collision) {\n    throw new Error('Collided but nothing to track to');\n  }\n\n  var _getAvailableMonsterR = getAvailableMonsterRoutes({\n    newPosition: newPosition,\n    collision: collision,\n    plane: plane,\n    trackTo: trackTo,\n    monster: monster\n  }),\n      availableOptions = _getAvailableMonsterR.availableOptions,\n      distanceFromTrack = _getAvailableMonsterR.distanceFromTrack;\n\n  if (!availableOptions.length) {\n    // this happens when wrapping\n    return {\n      position: newPosition\n    };\n  }\n\n  var vectors = getAvailableVectors({\n    newPosition: newPosition,\n    plane: plane,\n    trackTo: trackTo,\n    distanceFromTrack: distanceFromTrack,\n    movedDistance: movedDistance,\n    availableOptions: availableOptions,\n    player: player,\n    eating: monster.eatingTime > 0\n  });\n  var distanceFromPlayer = (0, _movement.gridDistance)(vectors[0].position, player.position);\n\n  if (distanceFromPlayer < constants.PLAYER_RADIUS * 1.8) {\n    if (monster.eatingTime) {\n      // monster got eaten\n      return {\n        deadTime: constants.MONSTER_DEATH_TIME_SECONDS\n      };\n    } // player got eaten\n\n\n    return {\n      lost: true\n    };\n  }\n\n  return vectors[0];\n}\n\nfunction getNewMonsterVector(monster, player, time) {\n  if (monster.deadTime > time) {\n    return _extends({}, monster, {\n      deadTime: monster.deadTime - time\n    });\n  }\n\n  if (monster.deadTime > 0) {\n    return _extends({}, monster, {\n      deadTime: 0,\n      eatingTime: 0,\n      position: monster.startingPosition,\n      direction: monster.startingDirection\n    });\n  }\n\n  var eatingTime = Math.max(0, monster.eatingTime - time);\n  var isHome = getIsHome(monster);\n  var speed = monster.eatingTime ? constants.MONSTER_SPEED_RETREAT : constants.MONSTER_SPEED_ATTACK;\n\n  try {\n    var _getNewPosition = (0, _movement.getNewPosition)(monster.position, monster.direction, speed, time, !isHome),\n        newPosition = _getNewPosition.newPosition,\n        collision = _getNewPosition.collision,\n        movedDistance = _getNewPosition.movedDistance;\n\n    if (isHome) {\n      return getNextMonsterHomePosition(newPosition, monster, player);\n    }\n\n    return _extends({}, getNavigatedMonsterVector(newPosition, collision, movedDistance, monster, player), {\n      eatingTime: eatingTime\n    });\n  } catch (err) {\n    // wrapped or something\n    return {};\n  }\n}\n\nfunction animateMonster(state, time, player, monster, index) {\n  var _getNewMonsterVector = getNewMonsterVector(monster, player, time),\n      lost = _getNewMonsterVector.lost,\n      monsterVector = _objectWithoutProperties(_getNewMonsterVector, ['lost']);\n\n  var newMonsters = state.monsters.slice();\n  newMonsters[index] = _extends({}, monster, monsterVector);\n\n  if (lost) {\n    return _extends({}, state, {\n      lost: true\n    });\n  }\n\n  return _extends({}, state, {\n    monsters: newMonsters\n  });\n}\n\nfunction animateMonsters(state, time, player) {\n  return state.monsters.reduce(function (lastState, monster, index) {\n    return animateMonster(lastState, time, player, monster, index);\n  }, state);\n}","map":null,"metadata":{},"sourceType":"script"}
{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\nvar _slicedToArray = function () {\n  function sliceIterator(arr, i) {\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n    var _e = undefined;\n\n    try {\n      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n        _arr.push(_s.value);\n\n        if (i && _arr.length === i) break;\n      }\n    } catch (err) {\n      _d = true;\n      _e = err;\n    } finally {\n      try {\n        if (!_n && _i[\"return\"]) _i[\"return\"]();\n      } finally {\n        if (_d) throw _e;\n      }\n    }\n\n    return _arr;\n  }\n\n  return function (arr, i) {\n    if (Array.isArray(arr)) {\n      return arr;\n    } else if (Symbol.iterator in Object(arr)) {\n      return sliceIterator(arr, i);\n    } else {\n      throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n    }\n  };\n}();\n\nexports.default = Line;\n\nvar _react = require('react');\n\nvar _react2 = _interopRequireDefault(_react);\n\nvar _propTypes = require('prop-types');\n\nvar _propTypes2 = _interopRequireDefault(_propTypes);\n\nvar _constants = require('../../constants');\n\nvar constants = _interopRequireWildcard(_constants);\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  } else {\n    var newObj = {};\n\n    if (obj != null) {\n      for (var key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];\n      }\n    }\n\n    newObj.default = obj;\n    return newObj;\n  }\n}\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _objectWithoutProperties(obj, keys) {\n  var target = {};\n\n  for (var i in obj) {\n    if (keys.indexOf(i) >= 0) continue;\n    if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;\n    target[i] = obj[i];\n  }\n\n  return target;\n}\n\nfunction getCornerArc(cornerArcRadius, clockwise, diffX, diffY) {\n  return 'a' + cornerArcRadius + ',' + cornerArcRadius + ' 0 0 ' + (clockwise >> 0) + ' ' + diffX + ',' + diffY;\n}\n\nvar pmod = function pmod(num, base) {\n  return (num % base + base) % base;\n};\n\nfunction getLinePart(_ref) {\n  var radiusA = _ref.radiusA,\n      radiusB = _ref.radiusB,\n      path = _ref.path,\n      lastDirection = _ref.lastDirection,\n      distance = _ref.distance,\n      direction = _ref.direction,\n      index = _ref.index,\n      end = _ref.end;\n  var vertical = direction % 2;\n  var horizontal = 1 - vertical;\n  var reverse = Math.pow(-1, (direction < 2) >> 0);\n  var polarity = Math.pow(-1, vertical);\n  var vectorType = ['h', 'v'][vertical];\n\n  if (index === 0) {\n    var _vector = (radiusB - distance) * reverse * polarity;\n\n    var _line = '' + vectorType + _vector;\n\n    return path + ' ' + _line;\n  }\n\n  var vector = (radiusA + radiusB * (!end >> 0) - distance) * reverse * polarity;\n  var line = '' + vectorType + vector;\n  var cornerArcDiffX = radiusA * (Math.pow(-1, (lastDirection === constants.WEST) >> 0) * vertical - reverse * horizontal);\n  var cornerArcDiffY = radiusA * (Math.pow(-1, (lastDirection === constants.NORTH) >> 0) * horizontal + reverse * vertical);\n  var clockwise = (pmod(lastDirection - direction, 4) === 1) >> 0;\n  var cornerArc = getCornerArc(radiusA, clockwise, cornerArcDiffX, cornerArcDiffY);\n  return path + ' ' + cornerArc + ' ' + line;\n}\n\nfunction getPoint(_ref2, gridSize) {\n  var _ref3 = _slicedToArray(_ref2, 2),\n      xValue = _ref3[0],\n      yValue = _ref3[1];\n\n  return [xValue * gridSize, (constants.BOARD_HEIGHT - yValue) * gridSize];\n}\n\nfunction Line(_ref4) {\n  var gridSize = _ref4.gridSize,\n      start = _ref4.start,\n      parts = _ref4.parts,\n      props = _objectWithoutProperties(_ref4, ['gridSize', 'start', 'parts']);\n\n  var startTransformed = getPoint(start, gridSize);\n  var partRadius = parts.map(function (_ref5) {\n    var radius = _ref5.radius;\n    return gridSize / (radius || 3);\n  });\n\n  var _parts$map$reduce = parts.map(function (_ref6) {\n    var distance = _ref6.distance,\n        rest = _objectWithoutProperties(_ref6, ['distance']);\n\n    return _extends({\n      distance: distance * gridSize\n    }, rest);\n  }).reduce(function (_ref7, _ref8, index) {\n    var path = _ref7.path,\n        lastDirection = _ref7.lastDirection,\n        lastRadius = _ref7.lastRadius;\n    var distance = _ref8.distance,\n        direction = _ref8.direction;\n    return {\n      path: getLinePart({\n        radiusA: lastRadius,\n        radiusB: partRadius[index],\n        path: path,\n        lastDirection: lastDirection,\n        distance: distance,\n        direction: direction,\n        index: index,\n        end: index === parts.length - 1\n      }),\n      lastDirection: direction,\n      lastRadius: partRadius[index]\n    };\n  }, {\n    path: 'M' + startTransformed.join(',')\n  }),\n      pathString = _parts$map$reduce.path;\n\n  var pathProps = {\n    strokeWidth: props.strokeWidth,\n    stroke: props.stroke,\n    fill: props.fill\n  };\n  return _react2.default.createElement('path', _extends({\n    d: pathString\n  }, pathProps));\n}\n\nLine.propTypes = {\n  strokeWidth: _propTypes2.default.number,\n  stroke: _propTypes2.default.string,\n  fill: _propTypes2.default.string,\n  gridSize: _propTypes2.default.number.isRequired,\n  start: _propTypes2.default.array.isRequired,\n  parts: _propTypes2.default.array.isRequired\n};","map":null,"metadata":{},"sourceType":"script"}
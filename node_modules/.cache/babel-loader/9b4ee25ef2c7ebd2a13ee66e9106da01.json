{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.gridDistance = gridDistance;\nexports.orderPolarity = orderPolarity;\nexports.getNewPosition = getNewPosition;\nexports.snapToTrack = snapToTrack;\nexports.getChangedVector = getChangedVector;\n\nvar _tracks = require('./tracks');\n\nvar _tracks2 = _interopRequireDefault(_tracks);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction gridDistance(posA, posB) {\n  // The Pacman board is a kind of manhattan style map, with constraints\n  // due to walls\n  return Math.abs(posA[0] - posB[0]) + Math.abs(posA[1] - posB[1]);\n}\n\nfunction orderPolarity(direction) {\n  var order = (direction < 2) >> 0;\n  var polarity = Math.pow(-1, 1 - order);\n  var plane = direction % 2;\n  return {\n    order: order,\n    polarity: polarity,\n    plane: plane\n  };\n}\n\nfunction getNewPosition(position, direction, speed, time) {\n  var toNearestPlane = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;\n\n  var _orderPolarity = orderPolarity(direction),\n      order = _orderPolarity.order,\n      plane = _orderPolarity.plane,\n      polarity = _orderPolarity.polarity;\n\n  var newPosition = position.slice();\n  var movedVector = polarity * speed * time;\n  var movedDistance = Math.abs(movedVector);\n  var nearestOtherPlane = Math.round(newPosition[1 - plane]);\n\n  if (toNearestPlane) {\n    newPosition[1 - plane] = nearestOtherPlane;\n  }\n\n  newPosition[plane] += movedVector;\n  var track = _tracks2.default[plane][nearestOtherPlane];\n  var trackHit = track.findIndex(function (limits) {\n    return position[plane] >= limits[0] && position[plane] <= limits[1] && polarity * newPosition[plane] > polarity * limits[order];\n  });\n  var collision = false;\n\n  if (trackHit === (track.length - 1) * order && track[trackHit][2]) {\n    // wrap\n    newPosition[plane] = track[(track.length - 1) * (1 - order)][1 - order];\n    movedDistance = speed * time;\n  } else if (trackHit > -1) {\n    newPosition[plane] = track[trackHit][order];\n    movedDistance = Math.abs(position[plane] - track[trackHit][order]);\n    collision = true;\n  }\n\n  return {\n    newPosition: newPosition,\n    collision: collision,\n    movedDistance: movedDistance\n  };\n}\n\nfunction snapToTrack(plane, order, position, tolerance) {\n  var snap = order ? Math.ceil(position[plane]) : Math.floor(position[plane]);\n\n  if (Math.abs(snap - position[plane]) > tolerance) {\n    return -1;\n  }\n\n  return snap;\n}\n\nfunction getChangedVector(oldPosition, newPosition, oldDirection, newDirection, movedDistance) {\n  var _orderPolarity2 = orderPolarity(oldDirection),\n      oldPlane = _orderPolarity2.plane,\n      oldOrder = _orderPolarity2.order;\n\n  var trackTo = snapToTrack(oldPlane, oldOrder, newPosition, movedDistance);\n\n  if (trackTo === -1) {\n    return null;\n  }\n\n  var old0 = oldPosition[oldPlane];\n  var new0 = newPosition[oldPlane];\n  var movedDistanceBeforeTurn = Math.abs(trackTo - newPosition[oldPlane]);\n\n  if (!(old0 === new0 && movedDistanceBeforeTurn > movedDistance)) {\n    var _orderPolarity3 = orderPolarity(newDirection),\n        newOrder = _orderPolarity3.order,\n        newPlane = _orderPolarity3.plane,\n        polarity = _orderPolarity3.polarity;\n\n    var track = _tracks2.default[newPlane][trackTo];\n\n    if (!track) {\n      return null;\n    }\n\n    var trackHit = track.findIndex(function (limits) {\n      return newPosition[newPlane] >= limits[0] && newPosition[newPlane] <= limits[1] && (1 - newOrder) * newPosition[newPlane] >= (limits[0] - polarity) * (1 - newOrder) && newOrder * newPosition[newPlane] <= (limits[1] - polarity) * newOrder;\n    });\n\n    if (trackHit > -1) {\n      var changedVector = newPosition.slice();\n      changedVector[oldPlane] = trackTo;\n      changedVector[newPlane] += polarity * (movedDistance - movedDistanceBeforeTurn);\n      return changedVector;\n    }\n  }\n\n  return null;\n}","map":null,"metadata":{},"sourceType":"script"}